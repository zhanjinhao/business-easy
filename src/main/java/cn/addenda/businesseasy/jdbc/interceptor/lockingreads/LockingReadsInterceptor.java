package cn.addenda.businesseasy.jdbc.interceptor.lockingreads;

import cn.addenda.businesseasy.jdbc.interceptor.InterceptorAdapter;
import com.alibaba.druid.filter.FilterChain;
import com.alibaba.druid.proxy.jdbc.ConnectionProxy;
import com.alibaba.druid.proxy.jdbc.PreparedStatementProxy;
import java.sql.SQLException;
import lombok.extern.slf4j.Slf4j;

/**
 * @author addenda
 * @datetime 2023/4/27 20:19
 */
@Slf4j
public class LockingReadsInterceptor extends InterceptorAdapter {

    @Override
    public PreparedStatementProxy connection_prepareStatement(
        FilterChain chain, ConnectionProxy connection, String sql) throws SQLException {
        sql = process(sql);
        return super.connection_prepareStatement(chain, connection, sql);
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(
        FilterChain chain, ConnectionProxy connection, String sql, int autoGeneratedKeys) throws SQLException {
        sql = process(sql);
        return super.connection_prepareStatement(chain, connection, sql, autoGeneratedKeys);
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(
        FilterChain chain, ConnectionProxy connection, String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        sql = process(sql);
        return super.connection_prepareStatement(chain, connection, sql, resultSetType, resultSetConcurrency);
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(
        FilterChain chain, ConnectionProxy connection, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        sql = process(sql);
        return super.connection_prepareStatement(chain, connection, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(
        FilterChain chain, ConnectionProxy connection, String sql, int[] columnIndexes) throws SQLException {
        sql = process(sql);
        return super.connection_prepareStatement(chain, connection, sql, columnIndexes);
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(
        FilterChain chain, ConnectionProxy connection, String sql, String[] columnNames) throws SQLException {
        sql = process(sql);
        return super.connection_prepareStatement(chain, connection, sql, columnNames);
    }

    private String process(String sql) {
        log.debug("Locking Reads, before sql rewriting: [{}].", sql);
        String lock = LockingReadsContext.getLock();
        if (lock == null) {
            // no-op
        } else if (LockingReadsContext.R_LOCK.equals(lock)) {
            sql = sql + " lock in share mode";
        } else if (LockingReadsContext.W_LOCK.equals(lock)) {
            sql = sql + " for update";
        } else {
            throw new LockingReadsException("不支持的LOCK类型，当前LOCK类型：" + lock + "。");
        }

        log.debug("Locking Reads, after sql rewriting: [{}].", sql);
        return sql;
    }

}
